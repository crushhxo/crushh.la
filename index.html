<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>crushh.la</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      color: #111111;
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
      cursor: default;
    }

    .center-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-sizing: border-box;
      padding: 20px;
      perspective: 1200px;
      transform-style: preserve-3d;
    }

    .container {
      max-width: 520px;
      width: 100%;
    }

    /* outer shell: handles fade + 3D crash */
    .logo-shell {
      display: flex;
      justify-content: center;
      margin: 0 auto 24px auto;
      opacity: 0;
      transform: translateZ(0);
      will-change: transform, opacity, filter;
    }

    /* inner img: only for flicker */
    .logo {
      width: 100%;
      max-width: 420px;
      height: auto;
      display: block;
      opacity: 1;
      transform: translate(0, 0) skewX(0deg);
      will-change: transform, opacity, filter;
    }

    /* normal fade-in for direct visits */
    .logo-shell.normal-in {
      animation: logoInitialFade 2.2s ease forwards;
      animation-delay: 0.4s;
    }

    /* crash-in from 404 */
    .logo-shell.crash-in {
      transform-origin: center center;
      animation: logoCrash 0.8s cubic-bezier(0.2, 0.8, 0.25, 1.1) forwards;
    }

    @keyframes logoInitialFade {
      0%   { opacity: 0; transform: translateY(4px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* 3D crash: from "in front of face" onto glass */
    @keyframes logoCrash {
      0% {
        opacity: 0;
        transform: translateZ(950px) scale(2.9) rotateX(16deg);
        filter: blur(12px) contrast(1.35);
      }
      30% {
        opacity: 1;
        transform: translateZ(200px) scale(1.6) rotateX(8deg);
        filter: blur(6px) contrast(1.25);
      }
      55% {
        opacity: 1;
        transform: translateZ(0) scale(1.04) rotateX(0deg);
        filter: blur(1px) contrast(1.12);
      }
      78% {
        transform: translateZ(-28px) scale(0.985);
        filter: blur(0.4px) contrast(1.04);
      }
      100% {
        opacity: 1;
        transform: translateZ(0) scale(1);
        filter: none;
      }
    }

    /* synth piano layout */
    .synth {
      margin-top: 28px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .piano {
      position: relative;
      width: 260px;
      height: 110px;
      margin: 0 auto 10px auto;
      display: block;
      animation: pianoFloat 6s ease-in-out infinite alternate;
    }

    @keyframes pianoFloat {
      0% { transform: translateY(0); }
      100% { transform: translateY(-3px); }
    }

    .white-keys {
      position: absolute;
      inset: 0;
      display: flex;
      gap: 0;
    }

    .black-keys {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 65%;
      pointer-events: none; /* let inner buttons receive events */
    }

    .key {
      border-radius: 3px;
      cursor: pointer;
      user-select: none;
      position: relative;
      overflow: hidden;
      transition:
        background 90ms ease,
        transform 90ms ease,
        filter 90ms ease,
        border-color 90ms ease;
    }

    /* subtle grunge / noise overlay tuned to grey tones */
    .key::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(0,0,0,0.05) 0, transparent 40%),
        radial-gradient(circle at 80% 60%, rgba(0,0,0,0.04) 0, transparent 45%),
        radial-gradient(circle at 30% 80%, rgba(0,0,0,0.045) 0, transparent 50%);
      mix-blend-mode: multiply;
      opacity: 0.4;
    }

    .key.white {
      flex: 1;
      height: 100%;
      border: 1px solid #b9b9b9;
      background: linear-gradient(to bottom, #d7d7d7 0%, #c5c5c5 100%);
    }

    .key.black {
      position: absolute;
      width: 22px;
      height: 70%;
      border: 1px solid #747272;
      background: linear-gradient(to bottom, #9c9a97 0%, #7c7a77 100%);
      z-index: 2;
      pointer-events: auto;
    }

    /* positions for 5 black keys over 8 white keys (C–C) */
    .key.black.csharp { left: 22px; }
    .key.black.dsharp { left: 54px; }
    .key.black.fsharp { left: 117px; }
    .key.black.gsharp { left: 149px; }
    .key.black.asharp { left: 181px; }

    .key:active,
    .key.is-down {
      transform: translateY(1px);
      filter: brightness(0.94) contrast(1.03);
      border-color: #9c9c9c;
    }

    .email a {
      font-size: 16px;
      color: #111111;
      text-decoration: none;
      border-bottom: 1px solid #11111133;
      padding-bottom: 2px;
    }

    .email a:hover {
      opacity: 0.6;
    }

    .cursor-trail {
      position: fixed;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.1);
      pointer-events: none;
      transform: translate(-50%, -50%);
      filter: blur(5px);
      animation: trailFade 0.7s ease-out forwards;
      z-index: 10;
    }

    @keyframes trailFade {
      0%   { opacity: 0.55; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0;    transform: translate(-50%, -50%) scale(1.7); }
    }
  </style>
</head>
<body>

  <div class="center-shell">
    <div class="container">
      <!-- outer shell handles slam -->
      <div class="logo-shell">
        <img class="logo" src="crushh-logo-rust-tp.png" alt="crushh logo" />
      </div>

      <!-- saw synth piano, C1–C2 -->
      <div class="synth">
        <div class="piano">
          <div class="white-keys">
            <button class="key white" data-note="C1"></button>
            <button class="key white" data-note="D1"></button>
            <button class="key white" data-note="E1"></button>
            <button class="key white" data-note="F1"></button>
            <button class="key white" data-note="G1"></button>
            <button class="key white" data-note="A1"></button>
            <button class="key white" data-note="B1"></button>
            <button class="key white" data-note="C2"></button>
          </div>
          <div class="black-keys">
            <button class="key black csharp" data-note="C#1"></button>
            <button class="key black dsharp" data-note="D#1"></button>
            <button class="key black fsharp" data-note="F#1"></button>
            <button class="key black gsharp" data-note="G#1"></button>
            <button class="key black asharp" data-note="A#1"></button>
          </div>
        </div>
      </div>

      <div class="email">
        <a href="mailto:contact@crushh.la">contact@crushh.la</a>
      </div>
    </div>
  </div>

  <script>
    // Crash + flicker logic for logo
    document.addEventListener("DOMContentLoaded", () => {
      const logo = document.querySelector(".logo");        // inner img for flicker
      const shell = document.querySelector(".logo-shell"); // outer for crash/fade
      if (!logo || !shell) return;

      const shouldCrash = sessionStorage.getItem("crushhCrash") === "1";
      let glitchStarted = false;

      function startGlitch() {
        if (glitchStarted) return;
        glitchStarted = true;

        function doGlitch() {
          const intensity = Math.random();      // 0–1
          const maxOffset = 3;
          const maxSkew = 3;

          const dx = (Math.random() - 0.5) * maxOffset * intensity;
          const dy = (Math.random() - 0.5) * maxOffset * intensity;
          const skewX = (Math.random() - 0.5) * maxSkew * intensity;
          const opacity = 0.85 + Math.random() * 0.15; // 0.85–1.0

          logo.style.transition =
            "transform 90ms ease-out, opacity 90ms ease-out, filter 90ms ease-out";
          logo.style.opacity = opacity.toString();
          logo.style.transform = `translate(${dx}px, ${dy}px) skewX(${skewX}deg)`;
          logo.style.filter =
            `contrast(${1.1 + intensity * 0.4}) saturate(${1 + intensity * 0.3})`;

          const resetDelay = 140 + Math.random() * 120;
          setTimeout(() => {
            logo.style.transform = "translate(0, 0) skewX(0deg)";
            logo.style.opacity = "1";
            logo.style.filter = "none";
          }, resetDelay);
        }

        function scheduleGlitch() {
          const delay = 320 + Math.random() * 720; // 320–1040ms
          setTimeout(() => {
            doGlitch();
            scheduleGlitch();
          }, delay);
        }

        scheduleGlitch();
      }

      if (shouldCrash) {
        // only crash once per 404 → home
        sessionStorage.removeItem("crushhCrash");

        // start shell from far pose (visual only; animation takes over)
        shell.style.opacity = "0";
        shell.style.transform = "translateZ(950px) scale(2.9) rotateX(16deg)";
        shell.style.filter = "blur(12px) contrast(1.35)";

        // ensure browser paints initial state, then trigger crash animation
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            shell.classList.add("crash-in");
          });
        });

        // when crash finishes, start flicker on the inner logo
        shell.addEventListener(
          "animationend",
          () => {
            shell.classList.remove("crash-in");
            shell.style.opacity = "1";
            shell.style.transform = "translateZ(0)";
            shell.style.filter = "none";
            startGlitch();
          },
          { once: true }
        );
      } else {
        // normal initial fade, then glitch (same flicker as original)
        shell.classList.add("normal-in");
        setTimeout(() => {
          startGlitch();
        }, 2600);
      }
    });

    // Web Audio saw synth C1–C2 with glide + sliding
    document.addEventListener("DOMContentLoaded", () => {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (!AudioContext) {
        console.warn("Web Audio API not supported in this browser.");
        return;
      }

      let audioCtx = null;

      // *** iOS Safari / iOS Chrome audio unlock ***
      function unlockAudio() {
        try {
          if (!audioCtx) {
            audioCtx = new AudioContext();
          }
          if (audioCtx.state === "suspended") {
            audioCtx.resume();
          }
        } catch (e) {
          console.warn("Audio unlock failed:", e);
        } finally {
          // Only need to unlock once
          window.removeEventListener("touchstart", unlockAudio);
          window.removeEventListener("mousedown", unlockAudio);
        }
      }

      // First user interaction: unlock audio for iOS Safari + Chrome
      window.addEventListener("touchstart", unlockAudio, { passive: true });
      window.addEventListener("mousedown", unlockAudio);

      function ensureAudioReady(callback) {
        if (!audioCtx) {
          audioCtx = new AudioContext();
        }
        if (audioCtx.state === "running") {
          callback(audioCtx);
        } else {
          // Fallback – usually won't be needed once unlocked
          audioCtx.resume().then(() => {
            callback(audioCtx);
          }).catch(() => {
            // ignore
          });
        }
      }

      // Note → frequency map (C1–C2) with sharps
      const noteFreq = {
        C1: 32.70,
        "C#1": 34.65,
        D1: 36.71,
        "D#1": 38.89,
        E1: 41.20,
        F1: 43.65,
        "F#1": 46.25,
        G1: 49.00,
        "G#1": 51.91,
        A1: 55.00,
        "A#1": 58.27,
        B1: 61.74,
        C2: 65.41
      };

      function createDistortionCurve(amount) {
        const k = typeof amount === "number" ? amount : 1;
        const n = 44100;
        const curve = new Float32Array(n);
        let x;
        // Simple symmetric soft clip: keeps one clear voice, adds gentle crunch
        const norm = Math.tanh(k);
        for (let i = 0; i < n; ++i) {
          x = (i * 2) / n - 1; // -1..1
          curve[i] = Math.tanh(k * x) / norm;
        }
        return curve;
      }

      let currentVoice = null; // { osc, gain }
      let activeKeyEl = null;
      const glideTime = 0.08; // ~80ms glide between notes

      function startOrGlideToNote(note) {
        const freq = noteFreq[note];
        if (!freq) return;

        ensureAudioReady((ctx) => {
          const now = ctx.currentTime;

          if (!currentVoice) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const distortion = ctx.createWaveShaper();

            osc.type = "sawtooth";
            osc.frequency.setValueAtTime(freq, now);

            // simple symmetric soft distortion, low drive for a single clear voice
            distortion.curve = createDistortionCurve(4);
            distortion.oversample = "2x";

            // quick attack, then hold at steady level
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.23, now + 0.02);

            osc.connect(distortion);
            distortion.connect(gain);
            gain.connect(ctx.destination);

            osc.start(now);

            currentVoice = { osc, gain };
          } else {
            const { osc } = currentVoice;
            osc.frequency.cancelScheduledValues(now);
            const currentFreq = osc.frequency.value;
            osc.frequency.setValueAtTime(currentFreq, now);
            // glide to new frequency
            osc.frequency.linearRampToValueAtTime(freq, now + glideTime);
          }
        });
      }

      function stopCurrentVoice() {
        if (!currentVoice) return;

        ensureAudioReady((ctx) => {
          const { osc, gain } = currentVoice;
          const now = ctx.currentTime;

          // short decay on release
          gain.gain.cancelScheduledValues(now);
          gain.gain.setValueAtTime(gain.gain.value, now);
          gain.gain.linearRampToValueAtTime(0, now + 0.06);

          osc.stop(now + 0.07);
          currentVoice = null;
        });
      }

      const piano = document.querySelector(".piano");
      const keys = document.querySelectorAll(".key[data-note]");
      if (!piano || !keys.length) return;

      let pointerDown = false;
      let activeTouchId = null;

      function setActiveKey(newKey) {
        if (activeKeyEl === newKey) return;
        if (activeKeyEl) {
          activeKeyEl.classList.remove("is-down");
        }
        activeKeyEl = newKey;
        if (activeKeyEl) {
          activeKeyEl.classList.add("is-down");
        }
      }

      function getKeyFromTarget(target) {
        if (!target) return null;
        if (target.classList && target.classList.contains("key") && target.dataset.note) {
          return target;
        }
        return target.closest ? target.closest(".key[data-note]") : null;
      }

      // Mouse logic: click + slide between keys
      keys.forEach((key) => {
        key.addEventListener("mousedown", (e) => {
          e.preventDefault();
          pointerDown = true;
          const note = key.getAttribute("data-note");
          setActiveKey(key);
          startOrGlideToNote(note);
        });
      });

      window.addEventListener("mouseup", () => {
        if (!pointerDown) return;
        pointerDown = false;
        setActiveKey(null);
        stopCurrentVoice();
      });

      piano.addEventListener("mousemove", (e) => {
        if (!pointerDown) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const note = key.getAttribute("data-note");
        if (!note) return;
        setActiveKey(key);
        startOrGlideToNote(note);
      });

      // Touch logic: tap + slide between keys
      piano.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (activeTouchId !== null) return;
        const touch = e.changedTouches[0];
        activeTouchId = touch.identifier;
        pointerDown = true;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const note = key.getAttribute("data-note");
        if (!note) return;
        setActiveKey(key);
        startOrGlideToNote(note);
      }, { passive: false });

      piano.addEventListener("touchmove", (e) => {
        if (activeTouchId === null) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const note = key.getAttribute("data-note");
        if (!note) return;
        setActiveKey(key);
        startOrGlideToNote(note);
      }, { passive: false });

      function endTouch(e) {
        if (activeTouchId === null) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        activeTouchId = null;
        pointerDown = false;
        setActiveKey(null);
        stopCurrentVoice();
      }

      piano.addEventListener("touchend", endTouch, { passive: false });
      piano.addEventListener("touchcancel", endTouch, { passive: false });
    });

    // Drunk-vision cursor trail
    document.addEventListener("mousemove", (e) => {
      const trail = document.createElement("div");
      trail.className = "cursor-trail";

      trail.style.left = e.clientX + "px";
      trail.style.top = e.clientY + "px";

      const scale = 0.9 + Math.random() * 0.4;
      trail.style.width = 14 * scale + "px";
      trail.style.height = 14 * scale + "px";
      trail.style.background = `rgba(0, 0, 0, ${0.08 + Math.random() * 0.07})`;
      trail.style.filter = "blur(" + (4 + Math.random() * 3) + "px)";

      document.body.appendChild(trail);
      setTimeout(() => trail.remove(), 750);
    });
  </script>

</body>
</html>