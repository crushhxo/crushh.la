<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>crushh.la</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      color: #111111;
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
      cursor: default;
    }

    .center-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-sizing: border-box;
      padding: 20px;
      perspective: 1200px;
      transform-style: preserve-3d;
    }

    .container {
      max-width: 520px;
      width: 100%;
    }

    /* outer shell: handles fade + 3D crash */
    .logo-shell {
      display: flex;
      justify-content: center;
      margin: 0 auto 24px auto;
      opacity: 0;
      transform: translateZ(0);
      will-change: transform, opacity, filter;
    }

    /* inner img: only for flicker */
    .logo {
      width: 100%;
      max-width: 420px;
      height: auto;
      display: block;
      opacity: 1;
      transform: translate(0, 0) skewX(0deg);
      will-change: transform, opacity, filter;
    }

    /* normal fade-in for direct visits */
    .logo-shell.normal-in {
      animation: logoInitialFade 2.2s ease forwards;
      animation-delay: 0.4s;
    }

    /* crash-in from 404 */
    .logo-shell.crash-in {
      transform-origin: center center;
      animation: logoCrash 0.8s cubic-bezier(0.2, 0.8, 0.25, 1.1) forwards;
    }

    @keyframes logoInitialFade {
      0%   { opacity: 0; transform: translateY(4px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    /* 3D crash: from "in front of face" onto glass */
    @keyframes logoCrash {
      0% {
        opacity: 0;
        transform: translateZ(950px) scale(2.9) rotateX(16deg);
        filter: blur(12px) contrast(1.35);
      }
      30% {
        opacity: 1;
        transform: translateZ(200px) scale(1.6) rotateX(8deg);
        filter: blur(6px) contrast(1.25);
      }
      55% {
        opacity: 1;
        transform: translateZ(0) scale(1.04) rotateX(0deg);
        filter: blur(1px) contrast(1.12);
      }
      78% {
        transform: translateZ(-28px) scale(0.985);
        filter: blur(0.4px) contrast(1.04);
      }
      100% {
        opacity: 1;
        transform: translateZ(0) scale(1);
        filter: none;
      }
    }

    /* synth piano layout */
    .synth {
      margin-top: 28px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .piano {
      position: relative;
      width: 260px;
      height: 110px;
      margin: 0 auto 10px auto;
      display: block;
      animation: pianoFloat 6s ease-in-out infinite alternate;
    }

    .drum-controls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .drum-button {
      font-size: 11px;
      text-transform: lowercase;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.25);
      background: rgba(0, 0, 0, 0.02);
      color: #111111;
      cursor: pointer;
      letter-spacing: 0.08em;
      transition: background 120ms ease, border-color 120ms ease, color 120ms ease, transform 80ms ease;
    }

    .drum-button:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .drum-button.active {
      background: #111111;
      color: #f7f7f7;
      border-color: #111111;
      transform: translateY(1px);
    }

    .step-indicator {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 4px;
    }

    .step-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
      box-sizing: border-box;
      border: 1px solid #111111;
      background: #ffffff;
      transition: background 80ms ease, transform 80ms ease;
    }

    .step-dot.active {
      background: #111111;
      transform: translateY(1px);
    }

    .seq-controls {
      margin-top: 6px;
      display: flex;
      justify-content: center;
    }

    .seq-button {
      font-size: 10px;
      text-transform: lowercase;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.35);
      background: rgba(0, 0, 0, 0.03);
      color: #111111;
      cursor: pointer;
      letter-spacing: 0.12em;
      transition: background 120ms ease, border-color 120ms ease, color 120ms ease, transform 80ms ease;
    }

    .seq-button.recording {
      background: #b80000;
      border-color: #b80000;
      color: #f7f7f7;
      transform: translateY(1px);
    }

    .seq-button.looping {
      background: #111111;
      border-color: #111111;
      color: #f7f7f7;
    }

    @keyframes pianoFloat {
      0% { transform: translateY(0); }
      100% { transform: translateY(-3px); }
    }

    .white-keys {
      position: absolute;
      inset: 0;
      display: flex;
      gap: 0;
    }

    .black-keys {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 65%;
      pointer-events: none; /* let inner buttons receive events */
    }

    .key {
      border-radius: 3px;
      cursor: pointer;
      user-select: none;
      position: relative;
      overflow: hidden;
      transition:
        background 90ms ease,
        transform 90ms ease,
        filter 90ms ease,
        border-color 90ms ease;
    }

    /* subtle grunge / noise overlay tuned to grey tones */
    .key::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(0,0,0,0.05) 0, transparent 40%),
        radial-gradient(circle at 80% 60%, rgba(0,0,0,0.04) 0, transparent 45%),
        radial-gradient(circle at 30% 80%, rgba(0,0,0,0.045) 0, transparent 50%);
      mix-blend-mode: multiply;
      opacity: 0.4;
    }

    .key.white {
      flex: 1;
      height: 100%;
      border: 1px solid #b9b9b9;
      background: linear-gradient(to bottom, #d7d7d7 0%, #c5c5c5 100%);
    }

    .key.black {
      position: absolute;
      width: 22px;
      height: 70%;
      border: 1px solid #747272;
      background: linear-gradient(to bottom, #9c9a97 0%, #7c7a77 100%);
      z-index: 2;
      pointer-events: auto;
    }

    /* positions for 5 black keys over 8 white keys (C–C) */
    .key.black.csharp { left: 22px; }
    .key.black.dsharp { left: 54px; }
    .key.black.fsharp { left: 117px; }
    .key.black.gsharp { left: 149px; }
    .key.black.asharp { left: 181px; }

    .ringer-note {
      font-size: 11px;
      font-style: italic;
      color: rgba(0, 0, 0, 0.55);
      margin-top: 6px;
      margin-bottom: 10px;
    }

    .key:active,
    .key.is-down {
      transform: translateY(1px);
      filter: brightness(0.94) contrast(1.03);
      border-color: #9c9c9c;
    }

    .email a {
      font-size: 16px;
      color: #111111;
      text-decoration: none;
      border-bottom: 1px solid #11111133;
      padding-bottom: 2px;
    }

    .email a:hover {
      opacity: 0.6;
    }

    .cursor-trail {
      position: fixed;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.1);
      pointer-events: none;
      transform: translate(-50%, -50%);
      filter: blur(5px);
      animation: trailFade 0.7s ease-out forwards;
      z-index: 10;
    }

    @keyframes trailFade {
      0%   { opacity: 0.55; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0;    transform: translate(-50%, -50%) scale(1.7); }
    }
  </style>
</head>
<body>

  <div class="center-shell">
    <div class="container">
      <!-- outer shell handles slam -->
      <div class="logo-shell">
        <img class="logo" src="crushh-logo-rust-tp.png" alt="crushh logo" />
      </div>

      <!-- saw synth piano, C1–C2 -->
      <div class="synth">
        <div class="piano">
          <div class="white-keys">
            <button class="key white" data-note="C1"></button>
            <button class="key white" data-note="D1"></button>
            <button class="key white" data-note="E1"></button>
            <button class="key white" data-note="F1"></button>
            <button class="key white" data-note="G1"></button>
            <button class="key white" data-note="A1"></button>
            <button class="key white" data-note="B1"></button>
            <button class="key white" data-note="C2"></button>
          </div>
          <div class="black-keys">
            <button class="key black csharp" data-note="C#1"></button>
            <button class="key black dsharp" data-note="D#1"></button>
            <button class="key black fsharp" data-note="F#1"></button>
            <button class="key black gsharp" data-note="G#1"></button>
            <button class="key black asharp" data-note="A#1"></button>
          </div>
        </div>
      </div>

      <!-- 16-step counter -->
      <div class="step-indicator" id="step-indicator"></div>

      <!-- recorder controls -->
      <div class="seq-controls">
        <button class="seq-button" id="seq-record">rec</button>
      </div>

      <!-- drum toggles -->
      <div class="drum-controls">
        <button class="drum-button" data-part="kick">kick</button>
        <button class="drum-button" data-part="snare">snare</button>
        <button class="drum-button" data-part="hats">hats</button>
        <button class="drum-button" data-part="perc">perc</button>
      </div>

      <div class="ringer-note"><em>ringer must be on to play</em></div>

      <div class="email">
        <a href="mailto:contact@crushh.la">contact@crushh.la</a>
      </div>
    </div>
  </div>

      <script>
    // --- iOS SUPER FIX: PRE-WARM AUDIO CONTEXT WITH A SILENT CLICK ---
    let iosAudioUnlocked = false;
    let audioCtx = null;

    function initAudioCtx() {
      if (!audioCtx) {
        const Ctor = window.AudioContext || window.webkitAudioContext;
        if (!Ctor) return;
        audioCtx = new Ctor();
      }
    }

    function unlockIOSAudio() {
      initAudioCtx();
      if (!audioCtx || iosAudioUnlocked) return;
      iosAudioUnlocked = true;
      try {
        const buffer = audioCtx.createBuffer(1, 1, 44100);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start(0); // tiny silent click
      } catch (e) {
        console.error("iOS unlock error:", e);
      }
    }

    ["touchstart", "touchend", "mousedown"].forEach((evt) => {
      window.addEventListener(
        evt,
        () => {
          initAudioCtx();
          if (!audioCtx) return;
          if (audioCtx.state !== "running") {
            audioCtx.resume().then(unlockIOSAudio).catch(() => {});
          } else {
            unlockIOSAudio();
          }
        },
        { passive: true }
      );
    });

    // Crash + flicker logic for logo
    document.addEventListener("DOMContentLoaded", () => {
      const logo = document.querySelector(".logo");        // inner img for flicker
      const shell = document.querySelector(".logo-shell"); // outer for crash/fade
      if (!logo || !shell) return;

      const shouldCrash = sessionStorage.getItem("crushhCrash") === "1";
      let glitchStarted = false;

      function startGlitch() {
        if (glitchStarted) return;
        glitchStarted = true;

        function doGlitch() {
          const intensity = Math.random();      // 0–1
          const maxOffset = 3;
          const maxSkew = 3;

          const dx = (Math.random() - 0.5) * maxOffset * intensity;
          const dy = (Math.random() - 0.5) * maxOffset * intensity;
          const skewX = (Math.random() - 0.5) * maxSkew * intensity;
          const opacity = 0.85 + Math.random() * 0.15; // 0.85–1.0

          logo.style.transition =
            "transform 90ms ease-out, opacity 90ms ease-out, filter 90ms ease-out";
          logo.style.opacity = opacity.toString();
          logo.style.transform = `translate(${dx}px, ${dy}px) skewX(${skewX}deg)`;
          logo.style.filter =
            `contrast(${1.1 + intensity * 0.4}) saturate(${1 + intensity * 0.3})`;

          const resetDelay = 140 + Math.random() * 120;
          setTimeout(() => {
            logo.style.transform = "translate(0, 0) skewX(0deg)";
            logo.style.opacity = "1";
            logo.style.filter = "none";
          }, resetDelay);
        }

        function scheduleGlitch() {
          const delay = 320 + Math.random() * 720; // 320–1040ms
          setTimeout(() => {
            doGlitch();
            scheduleGlitch();
          }, delay);
        }

        scheduleGlitch();
      }

      if (shouldCrash) {
        // only crash once per 404 → home
        sessionStorage.removeItem("crushhCrash");

        // start shell from far pose (visual only; animation takes over)
        shell.style.opacity = "0";
        shell.style.transform = "translateZ(950px) scale(2.9) rotateX(16deg)";
        shell.style.filter = "blur(12px) contrast(1.35)";

        // ensure browser paints initial state, then trigger crash animation
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            shell.classList.add("crash-in");
          });
        });

        // when crash finishes, start flicker on the inner logo
        shell.addEventListener(
          "animationend",
          () => {
            shell.classList.remove("crash-in");
            shell.style.opacity = "1";
            shell.style.transform = "translateZ(0)";
            shell.style.filter = "none";
            startGlitch();
          },
          { once: true }
        );
      } else {
        // normal initial fade, then glitch (same flicker as original)
        shell.classList.add("normal-in");
        setTimeout(() => {
          startGlitch();
        }, 2600);
      }
    });

    // Synth / drums / sequencer
    document.addEventListener("DOMContentLoaded", () => {
      if (!window.AudioContext && !window.webkitAudioContext) {
        console.warn("Web Audio API not supported in this browser.");
        return;
      }

      const BPM = 130;
      const BEAT_DUR = 60 / BPM;    // one beat in seconds
      const LOOP_BEATS = 16;        // 4 bars of 4/4
      const LOOP_STEPS = 64;        // 16ths across 4 bars
      const STEP_LEN = (LOOP_BEATS * BEAT_DUR) / LOOP_STEPS; // one 16th in seconds

      // Note → frequency map (C1–C2) with sharps
      const noteFreq = {
        C1: 32.70,
        "C#1": 34.65,
        D1: 36.71,
        "D#1": 38.89,
        E1: 41.20,
        F1: 43.65,
        "F#1": 46.25,
        G1: 49.00,
        "G#1": 51.91,
        A1: 55.00,
        "A#1": 58.27,
        B1: 61.74,
        C2: 65.41
      };

      // --- Scale lock: A major ---
      const keyboardOrder = [
        "C1","C#1","D1","D#1","E1","F1","F#1","G1","G#1","A1","A#1","B1","C2"
      ];
      const aMajorNotes = ["C#1","D1","E1","F#1","G#1","A1","B1"];
      const aMajorSet = new Set(aMajorNotes);
      const scaleMap = {};

      keyboardOrder.forEach((note, idx) => {
        if (aMajorSet.has(note)) {
          scaleMap[note] = note;
        } else {
          let best = null;
          let bestDist = Infinity;
          aMajorNotes.forEach((n) => {
            const j = keyboardOrder.indexOf(n);
            if (j === -1) return;
            const d = Math.abs(j - idx);
            if (d < bestDist) {
              bestDist = d;
              best = n;
            }
          });
          scaleMap[note] = best || note;
        }
      });

      function createDistortionCurve(amount) {
        const k = typeof amount === "number" ? amount : 1;
        const n = 44100;
        const curve = new Float32Array(n);
        let x;
        const norm = Math.tanh(k);
        for (let i = 0; i < n; ++i) {
          x = (i * 2) / n - 1; // -1..1
          curve[i] = Math.tanh(k * x) / norm;
        }
        return curve;
      }

      function getAudio() {
        initAudioCtx();
        if (!audioCtx) return null;
        if (audioCtx.state !== "running") {
          try {
            audioCtx.resume();
          } catch (e) {}
        }
        return audioCtx;
      }

      // Live synth voice for playing
      let currentVoice = null; // { osc, gain }
      const glideTime = 0.08;

      function startOrGlideToNote(rawNote) {
        const mapped = scaleMap[rawNote] || rawNote;
        const freq = noteFreq[mapped];
        if (!freq) return;

        const ctx = getAudio();
        if (!ctx) return;
        const now = ctx.currentTime;

        if (!currentVoice) {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const distortion = ctx.createWaveShaper();

          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(freq, now);

          distortion.curve = createDistortionCurve(4);
          distortion.oversample = "2x";

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.23, now + 0.02);

          osc.connect(distortion);
          distortion.connect(gain);
          gain.connect(ctx.destination);

          osc.start(now);

          currentVoice = { osc, gain };
        } else {
          const { osc } = currentVoice;
          osc.frequency.cancelScheduledValues(now);
          const currentFreq = osc.frequency.value;
          osc.frequency.setValueAtTime(currentFreq, now);
          osc.frequency.linearRampToValueAtTime(freq, now + glideTime);
        }
      }

      function stopCurrentVoice() {
        if (!currentVoice) return;
        const ctx = getAudio();
        if (!ctx) return;
        const now = ctx.currentTime;
        const { osc, gain } = currentVoice;

        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(gain.gain.value, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.06);

        osc.stop(now + 0.07);
        currentVoice = null;
      }

      // Drum loops
      const drumParts = ["kick", "snare", "hats", "perc"];
      const drumFiles = {
        kick: "sounds/Kick.wav",
        snare: "sounds/Snare.wav",
        hats: "sounds/Hats.wav",
        perc: "sounds/Perc.wav"
      };

      let drumLoaded = false;
      let drumLoading = false;
      const drumBuffers = {};
      const drumGains = {};
      const drumSources = {};

      async function loadDrumBuffers(ctx) {
        if (drumLoaded || drumLoading) return;
        drumLoading = true;
        try {
          for (const part of drumParts) {
            const url = drumFiles[part];
            const res = await fetch(url);
            const arr = await res.arrayBuffer();
            const buf = await ctx.decodeAudioData(arr);
            drumBuffers[part] = buf;
          }
          drumLoaded = true;
        } catch (e) {
          console.warn("Error loading drum loops:", e);
        } finally {
          drumLoading = false;
        }
      }

      async function ensureDrumsStarted() {
        const ctx = getAudio();
        if (!ctx) return;
        await loadDrumBuffers(ctx);
        if (Object.keys(drumSources).length) return;

        const startTime = ctx.currentTime + 0.05;
        for (const part of drumParts) {
          const buffer = drumBuffers[part];
          if (!buffer) continue;
          const src = ctx.createBufferSource();
          src.buffer = buffer;
          src.loop = true;

          const gain = ctx.createGain();
          gain.gain.setValueAtTime(0, startTime); // start muted

          src.connect(gain);
          gain.connect(ctx.destination);
          src.start(startTime);

          drumSources[part] = src;
          drumGains[part] = gain;
        }
      }

      async function toggleDrumPart(part, buttonEl) {
        await ensureDrumsStarted();
        const ctx = getAudio();
        if (!ctx) return;

        const gain = drumGains[part];
        if (!gain) return;

        const now = ctx.currentTime;
        const isOn = (gain.gain.value || 0) > 0.001;
        const target = isOn ? 0 : 0.375; // ~50% of old 0.75

        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(gain.gain.value, now);
        gain.gain.linearRampToValueAtTime(target, now + 0.03);

        if (buttonEl) {
          if (target > 0) {
            buttonEl.classList.add("active");
          } else {
            buttonEl.classList.remove("active");
          }
        }
      }

      // Sequencer grid: 64 steps (16ths)
      let grid = Array.from({ length: LOOP_STEPS }, () => []);
      let pendingNotes = {}; // note -> { startStep }

      // Transport for steps + visual bar
      let stepDots = [];
      let stepTimer = null;
      let currentStep = 0;
      let nextStepTime = 0;
      let transportStartTime = null;

      function triggerSeqNote(noteName, durationSeconds, startTime) {
        const mapped = scaleMap[noteName] || noteName;
        const freq = noteFreq[mapped];
        if (!freq) return;
        const ctx = getAudio();
        if (!ctx) return;

        const t0 = Math.max(startTime, ctx.currentTime);

        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const distortion = ctx.createWaveShaper();

        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(freq, t0);

        distortion.curve = createDistortionCurve(4);
        distortion.oversample = "2x";

        const attack = 0.02;
        const decay = 0.06;
        const sustainLevel = 0.22;
        const total = Math.max(0.08, durationSeconds);
        const release = 0.08;
        const sustainTime = Math.max(0, total - (attack + decay + release));

        gain.gain.setValueAtTime(0, t0);
        gain.gain.linearRampToValueAtTime(0.23, t0 + attack);
        gain.gain.linearRampToValueAtTime(sustainLevel, t0 + attack + decay);
        gain.gain.setValueAtTime(sustainLevel, t0 + attack + decay + sustainTime);
        gain.gain.linearRampToValueAtTime(0, t0 + total);

        osc.connect(distortion);
        distortion.connect(gain);
        gain.connect(ctx.destination);

        osc.start(t0);
        osc.stop(t0 + total + 0.05);
      }

      function startTransport(startAt) {
        const ctx = getAudio();
        if (!ctx) return;
        transportStartTime = startAt;
        currentStep = 0;
        nextStepTime = startAt;
        if (stepTimer) clearInterval(stepTimer);

        stepTimer = setInterval(() => {
          const c = getAudio();
          if (!c) return;
          const now = c.currentTime;
          const lookahead = 0.1;

          while (nextStepTime <= now + lookahead) {
            const stepIndex = currentStep;

            // quarter-note indicator: 4 steps per dot (64 steps / 16 dots)
            if (stepDots.length) {
              const quarterIndex = Math.floor(stepIndex / 4); // 0..15
              stepDots.forEach((dot, idx) => {
                if (idx === quarterIndex) {
                  dot.classList.add("active");
                } else {
                  dot.classList.remove("active");
                }
              });
            }

            // playback
            if (recState === "playing" && grid[stepIndex].length) {
              const when = nextStepTime;
              grid[stepIndex].forEach(evt => {
                triggerSeqNote(evt.note, evt.lengthSteps * STEP_LEN, when);
              });
            }

            currentStep = (currentStep + 1) % LOOP_STEPS;
            nextStepTime += STEP_LEN;
          }
        }, 25);
      }

      function stopTransport() {
        if (stepTimer) {
          clearInterval(stepTimer);
          stepTimer = null;
        }
        transportStartTime = null;
        if (stepDots.length) {
          stepDots.forEach(dot => dot.classList.remove("active"));
        }
      }

      // Recording state
      let recState = "idle";   // "idle" | "count-in" | "recording" | "playing"
      let recStartTime = null;
      let recEndTime = null;
      let currentRecordedNote = null; // mapped note currently down

      function recordNoteOn(note) {
        if (recState !== "recording") return;
        const ctx = getAudio();
        if (!ctx) return;
        const now = ctx.currentTime;
        if (now < recStartTime || now > recEndTime) return;

        const rel = now - recStartTime;
        let step = Math.round(rel / STEP_LEN);
        if (step < 0) step = 0;
        if (step >= LOOP_STEPS) step = LOOP_STEPS - 1;

        pendingNotes[note] = { startStep: step };
      }

      function recordNoteOff(note) {
        if (recState !== "recording") return;
        const ctx = getAudio();
        if (!ctx) return;
        const data = pendingNotes[note];
        if (!data) return;

        const now = ctx.currentTime;
        const rel = now - recStartTime;
        let endStep = Math.round(rel / STEP_LEN);

        if (endStep <= data.startStep) endStep = data.startStep + 1;
        if (endStep > LOOP_STEPS) endStep = LOOP_STEPS;

        const lengthSteps = endStep - data.startStep;
        if (lengthSteps > 0) {
          grid[data.startStep].push({ note, lengthSteps });
        }
        delete pendingNotes[note];
      }

      function finalizeRecording() {
        // Close any held notes at the end of the loop
        Object.entries(pendingNotes).forEach(([note, data]) => {
          const lengthSteps = LOOP_STEPS - data.startStep;
          if (lengthSteps > 0) {
            grid[data.startStep].push({ note, lengthSteps });
          }
        });
        pendingNotes = {};
      }

      // --- DOM wiring ---
      const piano = document.querySelector(".piano");
      const keys = document.querySelectorAll(".key[data-note]");
      if (!piano || !keys.length) return;

      const stepContainer = document.getElementById("step-indicator");
      if (stepContainer) {
        for (let i = 0; i < 16; i++) {
          const dot = document.createElement("div");
          dot.className = "step-dot";
          stepContainer.appendChild(dot);
          stepDots.push(dot);
        }
      }

      const drumButtons = document.querySelectorAll(".drum-button");
      drumButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const part = btn.getAttribute("data-part");
          if (!part) return;
          toggleDrumPart(part, btn);
        });
      });

      const recordBtn = document.getElementById("seq-record");
      if (recordBtn) {
        recordBtn.addEventListener("click", () => {
          const ctx = getAudio();
          if (!ctx) return;

          // If we are mid count-in / recording / playing → cancel back to idle
          if (recState === "count-in" || recState === "recording" || recState === "playing") {
            recState = "idle";
            finalizeRecording();
            stopTransport();
            grid = Array.from({ length: LOOP_STEPS }, () => []);
            pendingNotes = {};
            currentRecordedNote = null;
            recordBtn.classList.remove("recording", "looping");
            recordBtn.textContent = "rec";
            return;
          }

          // Start a fresh pass: 4-beat count-in, then record 4 bars, then loop
          ensureDrumsStarted();
          grid = Array.from({ length: LOOP_STEPS }, () => []);
          pendingNotes = {};
          currentRecordedNote = null;

          const now = ctx.currentTime;
          const baseTime = now + 0.3; // tiny lead-in so scheduling feels tight

          const countInBeats = 4;
          const recordBeats = LOOP_BEATS; // 16
          const countInDur = countInBeats * BEAT_DUR;
          const recordDur = recordBeats * BEAT_DUR;

          recStartTime = baseTime + countInDur;
          recEndTime = recStartTime + recordDur;

          recState = "count-in";
          recordBtn.classList.add("recording");
          recordBtn.classList.remove("looping");
          recordBtn.textContent = "count-in";

// --- COUNT-IN VISUAL (4 → 3 → 2 → 1) ---
for (let i = 0; i < 4; i++) {
  const beatTime = baseTime + i * BEAT_DUR;
  const displayNumber = 4 - i;

  // Schedule UI update on each beat
  setTimeout(() => {
    recordBtn.textContent = displayNumber.toString();
  }, (beatTime - now) * 1000);
}

// When count-in ends, show active recording state
setTimeout(() => {
  recordBtn.textContent = "rec*";
}, (recStartTime - now) * 1000);

          // Start transport at the actual bar 1, AFTER the 4-beat count-in
startTransport(recStartTime);

          // Switch into "recording" after count-in
          const toRecordMs = Math.max(0, (recStartTime - ctx.currentTime) * 1000);
          setTimeout(() => {
            if (recState !== "count-in") return;
            recState = "recording";
            recordBtn.textContent = "rec*";
          }, toRecordMs);

          // End recording after 4 bars and start looping
          const toEndMs = Math.max(0, (recEndTime - ctx.currentTime) * 1000);
          setTimeout(() => {
            if (recState !== "recording") return;
            recState = "playing";
            finalizeRecording();
            recordBtn.classList.remove("recording");
            recordBtn.classList.add("looping");
            recordBtn.textContent = "looping";
          }, toEndMs);
        });
      }

      // Pointer/touch interaction + recording hooks
      let pointerDown = false;
      let activeTouchId = null;
      let activeKeyEl = null;

      function setActiveKey(newKey) {
        if (activeKeyEl === newKey) return;
        if (activeKeyEl) {
          activeKeyEl.classList.remove("is-down");
        }
        activeKeyEl = newKey;
        if (activeKeyEl) {
          activeKeyEl.classList.add("is-down");
        }
      }

      function getKeyFromTarget(target) {
        if (!target) return null;
        if (target.classList && target.classList.contains("key") && target.dataset.note) {
          return target;
        }
        return target.closest ? target.closest(".key[data-note]") : null;
      }

      // Mouse
      keys.forEach((key) => {
        key.addEventListener("mousedown", (e) => {
          e.preventDefault();
          pointerDown = true;
          const rawNote = key.getAttribute("data-note");
          if (!rawNote) return;
          const mapped = scaleMap[rawNote] || rawNote;
          currentRecordedNote = mapped;

          setActiveKey(key);
          if (recState === "recording") {
            recordNoteOn(mapped);
          }
          startOrGlideToNote(rawNote);
        });
      });

      window.addEventListener("mouseup", () => {
        if (!pointerDown) return;
        pointerDown = false;
        if (recState === "recording" && currentRecordedNote) {
          recordNoteOff(currentRecordedNote);
        }
        currentRecordedNote = null;
        setActiveKey(null);
        stopCurrentVoice();
      });

      piano.addEventListener("mousemove", (e) => {
        if (!pointerDown) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const rawNote = key.getAttribute("data-note");
        if (!rawNote) return;
        const mapped = scaleMap[rawNote] || rawNote;

        if (mapped !== currentRecordedNote) {
          if (recState === "recording" && currentRecordedNote) {
            recordNoteOff(currentRecordedNote);
          }
          if (recState === "recording") {
            recordNoteOn(mapped);
          }
          currentRecordedNote = mapped;
        }

        setActiveKey(key);
        startOrGlideToNote(rawNote);
      });

      // Touch
      piano.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (activeTouchId !== null) return;
        const touch = e.changedTouches[0];
        activeTouchId = touch.identifier;
        pointerDown = true;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const rawNote = key.getAttribute("data-note");
        if (!rawNote) return;
        const mapped = scaleMap[rawNote] || rawNote;

        currentRecordedNote = mapped;
        setActiveKey(key);
        if (recState === "recording") {
          recordNoteOn(mapped);
        }
        startOrGlideToNote(rawNote);
      }, { passive: false });

      piano.addEventListener("touchmove", (e) => {
        if (activeTouchId === null) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const rawNote = key.getAttribute("data-note");
        if (!rawNote) return;
        const mapped = scaleMap[rawNote] || rawNote;

        if (mapped !== currentRecordedNote) {
          if (recState === "recording" && currentRecordedNote) {
            recordNoteOff(currentRecordedNote);
          }
          if (recState === "recording") {
            recordNoteOn(mapped);
          }
          currentRecordedNote = mapped;
        }

        setActiveKey(key);
        startOrGlideToNote(rawNote);
      }, { passive: false });

      function endTouch(e) {
        if (activeTouchId === null) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        activeTouchId = null;
        pointerDown = false;
        if (recState === "recording" && currentRecordedNote) {
          recordNoteOff(currentRecordedNote);
        }
        currentRecordedNote = null;
        setActiveKey(null);
        stopCurrentVoice();
      }

      piano.addEventListener("touchend", endTouch, { passive: false });
      piano.addEventListener("touchcancel", endTouch, { passive: false });
    });

    // Drunk-vision cursor trail
    document.addEventListener("mousemove", (e) => {
      const trail = document.createElement("div");
      trail.className = "cursor-trail";

      trail.style.left = e.clientX + "px";
      trail.style.top = e.clientY + "px";

      const scale = 0.9 + Math.random() * 0.4;
      trail.style.width = 14 * scale + "px";
      trail.style.height = 14 * scale + "px";
      trail.style.background = `rgba(0, 0, 0, ${0.08 + Math.random() * 0.07})`;
      trail.style.filter = "blur(" + (4 + Math.random() * 3) + "px)";

      document.body.appendChild(trail);
      setTimeout(() => trail.remove(), 750);
    });
  </script>

</body>
</html>