<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>crushh.la</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #ffffff;
      color: #111111;
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
      cursor: default;
    }

    .center-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      box-sizing: border-box;
      padding: 20px;
      perspective: 1200px;
      transform-style: preserve-3d;
    }

    .container {
      max-width: 620px;
      width: 100%;
    }

    /* outer shell: handles fade + 3D crash */
    .logo-shell {
      display: flex;
      justify-content: center;
      margin: 0 auto 24px auto;
      opacity: 0;
      transform: translateZ(0);
      will-change: transform, opacity, filter;
    }

    /* inner img: only for flicker */
    .logo {
      width: 100%;
      max-width: 420px;
      height: auto;
      display: block;
      opacity: 1;
      transform: translate(0, 0) skewX(0deg);
      will-change: transform, opacity, filter;
    }

    .logo-shell.normal-in {
      animation: logoInitialFade 2.2s ease forwards;
      animation-delay: 0.4s;
    }

    .logo-shell.crash-in {
      transform-origin: center center;
      animation: logoCrash 0.8s cubic-bezier(0.2, 0.8, 0.25, 1.1) forwards;
    }

    @keyframes logoInitialFade {
      0%   { opacity: 0; transform: translateY(4px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    @keyframes logoCrash {
      0% {
        opacity: 0;
        transform: translateZ(950px) scale(2.9) rotateX(16deg);
        filter: blur(12px) contrast(1.35);
      }
      30% {
        opacity: 1;
        transform: translateZ(200px) scale(1.6) rotateX(8deg);
        filter: blur(6px) contrast(1.25);
      }
      55% {
        opacity: 1;
        transform: translateZ(0) scale(1.04) rotateX(0deg);
        filter: blur(1px) contrast(1.12);
      }
      78% {
        transform: translateZ(-28px) scale(0.985);
        filter: blur(0.4px) contrast(1.04);
      }
      100% {
        opacity: 1;
        transform: translateZ(0) scale(1);
        filter: none;
      }
    }

    /* synth piano layout */
    .synth {
      margin-top: 28px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .piano {
      position: relative;
      width: 260px;
      height: 110px;
      margin: 0 auto 10px auto;
      display: block;
      animation: pianoFloat 6s ease-in-out infinite alternate;
    }

    @keyframes pianoFloat {
      0% { transform: translateY(0); }
      100% { transform: translateY(-3px); }
    }

    .white-keys {
      position: absolute;
      inset: 0;
      display: flex;
      gap: 0;
    }

    .black-keys {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 65%;
      pointer-events: none;
    }

    .key {
      border-radius: 3px;
      cursor: pointer;
      user-select: none;
      position: relative;
      overflow: hidden;
      transition:
        background 90ms ease,
        transform 90ms ease,
        filter 90ms ease,
        border-color 90ms ease;
    }

    .key::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(0,0,0,0.05) 0, transparent 40%),
        radial-gradient(circle at 80% 60%, rgba(0,0,0,0.04) 0, transparent 45%),
        radial-gradient(circle at 30% 80%, rgba(0,0,0,0.045) 0, transparent 50%);
      mix-blend-mode: multiply;
      opacity: 0.4;
    }

    .key.white {
      flex: 1;
      height: 100%;
      border: 1px solid #b9b9b9;
      background: linear-gradient(to bottom, #d7d7d7 0%, #c5c5c5 100%);
    }

    .key.black {
      position: absolute;
      width: 22px;
      height: 70%;
      border: 1px solid #747272;
      background: linear-gradient(to bottom, #9c9a97 0%, #7c7a77 100%);
      z-index: 2;
      pointer-events: auto;
    }

    .key.black.csharp { left: 22px; }
    .key.black.dsharp { left: 54px; }
    .key.black.fsharp { left: 117px; }
    .key.black.gsharp { left: 149px; }
    .key.black.asharp { left: 181px; }

    .key:active,
    .key.is-down {
      transform: translateY(1px);
      filter: brightness(0.94) contrast(1.03);
      border-color: #9c9c9c;
    }

    /* transport + sequencer */
    .transport {
      margin-top: 16px;
      display: flex;
      justify-content: center;
      gap: 6px;
    }

    .transport-button {
      font-size: 11px;
      text-transform: lowercase;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.35);
      background: rgba(0, 0, 0, 0.03);
      color: #111111;
      cursor: pointer;
      letter-spacing: 0.1em;
      transition: background 120ms ease, border-color 120ms ease, color 120ms ease, transform 80ms ease;
    }

    .transport-button:hover {
      background: rgba(0, 0, 0, 0.06);
    }

    .transport-button.active {
      background: #111111;
      color: #f7f7f7;
      border-color: #111111;
      transform: translateY(1px);
    }

    .step-indicator {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 4px;
    }

    .step-dot {
      width: 10px;
      height: 10px;
      border-radius: 2px;
      box-sizing: border-box;
      border: 1px solid #111111;
      background: #ffffff;
      transition: background 80ms ease, transform 80ms ease;
    }

    .step-dot.active {
      background: #111111;
      transform: translateY(1px);
    }

    .seq-controls {
      margin-top: 6px;
      display: flex;
      justify-content: center;
    }

    .seq-button {
      font-size: 10px;
      text-transform: lowercase;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.35);
      background: rgba(0, 0, 0, 0.03);
      color: #111111;
      cursor: pointer;
      letter-spacing: 0.12em;
      transition: background 120ms ease, border-color 120ms ease, color 120ms ease, transform 80ms ease;
    }

    .seq-button.recording {
      background: #b80000;
      border-color: #b80000;
      color: #f7f7f7;
      transform: translateY(1px);
    }

    .seq-button.looping {
      background: #111111;
      border-color: #111111;
      color: #f7f7f7;
    }

    /* drums */
    .drums {
      margin-top: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .drum-lane {
      width: 100%;
      max-width: 520px;
    }

    .drum-header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .drum-button {
      font-size: 11px;
      text-transform: lowercase;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.25);
      background: rgba(0, 0, 0, 0.02);
      color: #111111;
      cursor: pointer;
      letter-spacing: 0.08em;
      transition: background 120ms ease, border-color 120ms ease, color 120ms ease, transform 80ms ease;
    }

    .drum-button:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    .drum-button.active {
      background: #111111;
      color: #f7f7f7;
      border-color: #111111;
      transform: translateY(1px);
    }

    .drum-select {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, 0.3);
      background: rgba(0, 0, 0, 0.02);
      color: #111111;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      outline: none;
      cursor: pointer;
    }

    .drum-grid {
      margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(4, minmax(12px, 1fr));
      grid-template-rows: repeat(4, 16px);
      gap: 3px;
      max-width: 260px;
    }

    .drum-cell {
      border-radius: 2px;
      border: 1px solid #979797;
      background: #ffffff;
      box-sizing: border-box;
      cursor: pointer;
      transition: background 90ms ease, border-color 90ms ease, transform 90ms ease;
    }

    .drum-cell.active {
      background: #111111;
      border-color: #111111;
      transform: translateY(1px);
    }

    .ringer-note {
      font-size: 11px;
      font-style: italic;
      color: rgba(0, 0, 0, 0.55);
      margin-top: 8px;
      margin-bottom: 10px;
    }

    .email {
      margin-top: 12px;
    }

    .email a {
      font-size: 16px;
      color: #111111;
      text-decoration: none;
      border-bottom: 1px solid #11111133;
      padding-bottom: 2px;
    }

    .email a:hover {
      opacity: 0.6;
    }

    .cursor-trail {
      position: fixed;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.1);
      pointer-events: none;
      transform: translate(-50%, -50%);
      filter: blur(5px);
      animation: trailFade 0.7s ease-out forwards;
      z-index: 10;
    }

    @keyframes trailFade {
      0%   { opacity: 0.55; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0;    transform: translate(-50%, -50%) scale(1.7); }
    }
  </style>
</head>
<body>

  <div class="center-shell">
    <div class="container">
      <!-- logo -->
      <div class="logo-shell">
        <img class="logo" src="crushh-logo-rust-tp.png" alt="crushh logo" />
      </div>

      <!-- synth piano -->
      <div class="synth">
        <div class="piano">
          <div class="white-keys">
            <button class="key white" data-note="C1"></button>
            <button class="key white" data-note="D1"></button>
            <button class="key white" data-note="E1"></button>
            <button class="key white" data-note="F1"></button>
            <button class="key white" data-note="G1"></button>
            <button class="key white" data-note="A1"></button>
            <button class="key white" data-note="B1"></button>
            <button class="key white" data-note="C2"></button>
          </div>
          <div class="black-keys">
            <button class="key black csharp" data-note="C#1"></button>
            <button class="key black dsharp" data-note="D#1"></button>
            <button class="key black fsharp" data-note="F#1"></button>
            <button class="key black gsharp" data-note="G#1"></button>
            <button class="key black asharp" data-note="A#1"></button>
          </div>
        </div>
      </div>

      <!-- transport -->
      <div class="transport">
        <button class="transport-button" id="transport-play">play</button>
        <button class="transport-button" id="transport-stop">stop</button>
      </div>

      <!-- 16 quarter-note dots for 4 bars -->
      <div class="step-indicator" id="step-indicator"></div>

      <!-- recorder controls -->
      <div class="seq-controls">
        <button class="seq-button" id="seq-record">rec</button>
      </div>

      <!-- drums -->
      <div class="drums">
        <div class="drum-lane" data-part="kick">
          <div class="drum-header">
            <button class="drum-button" data-part="kick">kick</button>
            <select class="drum-select" data-part="kick">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="drum-grid" data-part="kick"></div>
        </div>

        <div class="drum-lane" data-part="snare">
          <div class="drum-header">
            <button class="drum-button" data-part="snare">snare</button>
            <select class="drum-select" data-part="snare">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="drum-grid" data-part="snare"></div>
        </div>

        <div class="drum-lane" data-part="ch">
          <div class="drum-header">
            <button class="drum-button" data-part="ch">ch</button>
            <select class="drum-select" data-part="ch">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="drum-grid" data-part="ch"></div>
        </div>

        <div class="drum-lane" data-part="oh">
          <div class="drum-header">
            <button class="drum-button" data-part="oh">oh</button>
            <select class="drum-select" data-part="oh">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="drum-grid" data-part="oh"></div>
        </div>

        <div class="drum-lane" data-part="perc">
          <div class="drum-header">
            <button class="drum-button" data-part="perc">perc</button>
            <select class="drum-select" data-part="perc">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="drum-grid" data-part="perc"></div>
        </div>
      </div>

      <div class="ringer-note"><em>ringer must be on to play</em></div>

      <div class="email">
        <a href="mailto:contact@crushh.la">contact@crushh.la</a>
      </div>
    </div>
  </div>

  <script>
    // --- iOS SUPER FIX: PRE-WARM AUDIO CONTEXT WITH A SILENT CLICK ---
    let iosAudioUnlocked = false;
    let audioCtx = null;

    function initAudioCtx() {
      if (!audioCtx) {
        const Ctor = window.AudioContext || window.webkitAudioContext;
        if (!Ctor) return;
        audioCtx = new Ctor();
      }
    }

    function unlockIOSAudio() {
      initAudioCtx();
      if (!audioCtx || iosAudioUnlocked) return;
      iosAudioUnlocked = true;
      try {
        const buffer = audioCtx.createBuffer(1, 1, 44100);
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start(0);
      } catch (e) {
        console.error("iOS unlock error:", e);
      }
    }

    ["touchstart", "touchend", "mousedown"].forEach((evt) => {
      window.addEventListener(
        evt,
        () => {
          initAudioCtx();
          if (!audioCtx) return;
          if (audioCtx.state !== "running") {
            audioCtx.resume().then(unlockIOSAudio).catch(() => {});
          } else {
            unlockIOSAudio();
          }
        },
        { passive: true }
      );
    });

    // Crash + flicker logic for logo
    document.addEventListener("DOMContentLoaded", () => {
      const logo = document.querySelector(".logo");
      const shell = document.querySelector(".logo-shell");
      if (!logo || !shell) return;

      const shouldCrash = sessionStorage.getItem("crushhCrash") === "1";
      let glitchStarted = false;

      function startGlitch() {
        if (glitchStarted) return;
        glitchStarted = true;

        function doGlitch() {
          const intensity = Math.random();
          const maxOffset = 3;
          const maxSkew = 3;

          const dx = (Math.random() - 0.5) * maxOffset * intensity;
          const dy = (Math.random() - 0.5) * maxOffset * intensity;
          const skewX = (Math.random() - 0.5) * maxSkew * intensity;
          const opacity = 0.85 + Math.random() * 0.15;

          logo.style.transition =
            "transform 90ms ease-out, opacity 90ms ease-out, filter 90ms ease-out";
          logo.style.opacity = opacity.toString();
          logo.style.transform = `translate(${dx}px, ${dy}px) skewX(${skewX}deg)`;
          logo.style.filter =
            `contrast(${1.1 + intensity * 0.4}) saturate(${1 + intensity * 0.3})`;

          const resetDelay = 140 + Math.random() * 120;
          setTimeout(() => {
            logo.style.transform = "translate(0, 0) skewX(0deg)";
            logo.style.opacity = "1";
            logo.style.filter = "none";
          }, resetDelay);
        }

        function scheduleGlitch() {
          const delay = 320 + Math.random() * 720;
          setTimeout(() => {
            doGlitch();
            scheduleGlitch();
          }, delay);
        }

        scheduleGlitch();
      }

      if (shouldCrash) {
        sessionStorage.removeItem("crushhCrash");

        shell.style.opacity = "0";
        shell.style.transform = "translateZ(950px) scale(2.9) rotateX(16deg)";
        shell.style.filter = "blur(12px) contrast(1.35)";

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            shell.classList.add("crash-in");
          });
        });

        shell.addEventListener(
          "animationend",
          () => {
            shell.classList.remove("crash-in");
            shell.style.opacity = "1";
            shell.style.transform = "translateZ(0)";
            shell.style.filter = "none";
            startGlitch();
          },
          { once: true }
        );
      } else {
        shell.classList.add("normal-in");
        setTimeout(() => {
          startGlitch();
        }, 2600);
      }
    });

    // Synth, drums, transport + sequencer
    document.addEventListener("DOMContentLoaded", () => {
      if (!window.AudioContext && !window.webkitAudioContext) {
        console.warn("Web Audio API not supported in this browser.");
        return;
      }

      // --- GLOBAL TRANSPORT ---
      const BPM = 130;
      const BEAT_DUR = 60 / BPM;       // seconds per beat
      const BARS = 4;
      const BEATS_PER_BAR = 4;
      const LOOP_BEATS = BARS * BEATS_PER_BAR; // 16
      const STEPS_PER_BAR = 16;        // 16ths in one bar
      const TOTAL_STEPS = STEPS_PER_BAR * BARS; // 64
      const STEP_DUR = BEAT_DUR / 4;   // 16th note

      let transportStartTime = null;
      let transportRunning = false;
      let stepTimer = null;
      let globalStepCounter = 0;
      let nextStepTime = 0;
      let lastQuarterVisual = null;

      function getAudio() {
        initAudioCtx();
        if (!audioCtx) return null;
        if (audioCtx.state !== "running") {
          try { audioCtx.resume(); } catch (e) {}
        }
        return audioCtx;
      }

      function getLoopPositionBeats(time) {
        if (transportStartTime === null) return 0;
        const elapsed = Math.max(0, time - transportStartTime);
        const loopDurSec = LOOP_BEATS * BEAT_DUR;
        const beats = elapsed / BEAT_DUR;
        return ((beats % LOOP_BEATS) + LOOP_BEATS) % LOOP_BEATS;
      }

      function timeToGlobalStep(time) {
        if (transportStartTime === null) return 0;
        const elapsed = Math.max(0, time - transportStartTime);
        const stepFloat = elapsed / STEP_DUR;
        return Math.round(stepFloat);
      }

      function startTransport() {
        const ctx = getAudio();
        if (!ctx) return;
        const now = ctx.currentTime;

        transportStartTime = now + 0.15;
        transportRunning = true;

        const rel = 0;
        globalStepCounter = 0;
        nextStepTime = transportStartTime + STEP_DUR;
        lastQuarterVisual = null;

        if (!stepTimer) {
          stepTimer = setInterval(() => {
            const c = getAudio();
            if (!c || !transportRunning) return;
            const now2 = c.currentTime;
            const lookahead = 0.1;

            while (nextStepTime <= now2 + lookahead) {
              globalStepCounter++;
              const localStep = globalStepCounter % TOTAL_STEPS;

              // visual 16 quarter notes over 4 bars
              if (stepDots.length) {
                const quarterIndex = Math.floor(localStep / 4); // 0..15
                if (quarterIndex !== lastQuarterVisual) {
                  stepDots.forEach((dot, idx) => {
                    dot.classList.toggle("active", idx === quarterIndex);
                  });
                  lastQuarterVisual = quarterIndex;
                }
              }

              // schedule drums & synth notes for this step
              scheduleDrumsForStep(localStep, nextStepTime);
              scheduleSynthForStep(localStep, nextStepTime);

              nextStepTime += STEP_DUR;
            }
          }, 25);
        }
      }

      function stopTransport() {
        transportRunning = false;
        if (stepTimer) {
          clearInterval(stepTimer);
          stepTimer = null;
        }
        lastQuarterVisual = null;
        globalStepCounter = 0;
        if (stepDots.length) {
          stepDots.forEach(dot => dot.classList.remove("active"));
        }
      }

      // --- SCALE: A major, note â†’ freq map ---
      const noteFreq = {
        C1: 32.70,
        "C#1": 34.65,
        D1: 36.71,
        "D#1": 38.89,
        E1: 41.20,
        F1: 43.65,
        "F#1": 46.25,
        G1: 49.00,
        "G#1": 51.91,
        A1: 55.00,
        "A#1": 58.27,
        B1: 61.74,
        C2: 65.41
      };

      const keyboardOrder = [
        "C1","C#1","D1","D#1","E1","F1","F#1","G1","G#1","A1","A#1","B1","C2"
      ];
      const aMajorNotes = ["C#1","D1","E1","F#1","G#1","A1","B1"];
      const aMajorSet = new Set(aMajorNotes);
      const scaleMap = {};
      keyboardOrder.forEach((note, idx) => {
        if (aMajorSet.has(note)) {
          scaleMap[note] = note;
        } else {
          let best = null;
          let bestDist = Infinity;
          aMajorNotes.forEach((n) => {
            const j = keyboardOrder.indexOf(n);
            if (j === -1) return;
            const d = Math.abs(j - idx);
            if (d < bestDist) {
              bestDist = d;
              best = n;
            }
          });
          scaleMap[note] = best || note;
        }
      });

      function createDistortionCurve(amount) {
        const k = typeof amount === "number" ? amount : 1;
        const n = 44100;
        const curve = new Float32Array(n);
        let x;
        const norm = Math.tanh(k);
        for (let i = 0; i < n; ++i) {
          x = (i * 2) / n - 1;
          curve[i] = Math.tanh(k * x) / norm;
        }
        return curve;
      }

      // --- LIVE SYNTH VOICE (monophonic) ---
      let currentVoice = null;
      const glideTime = 0.08;

      function startOrGlideToNote(rawNote) {
        const mapped = scaleMap[rawNote] || rawNote;
        const freq = noteFreq[mapped];
        if (!freq) return;

        const ctx = getAudio();
        if (!ctx) return;
        const now = ctx.currentTime;

        if (!currentVoice) {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          const distortion = ctx.createWaveShaper();

          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(freq, now);

          distortion.curve = createDistortionCurve(4);
          distortion.oversample = "2x";

          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.23, now + 0.02);

          osc.connect(distortion);
          distortion.connect(gain);
          gain.connect(ctx.destination);

          osc.start(now);

          currentVoice = { osc, gain };
        } else {
          const { osc } = currentVoice;
          osc.frequency.cancelScheduledValues(now);
          const currentFreq = osc.frequency.value;
          osc.frequency.setValueAtTime(currentFreq, now);
          osc.frequency.linearRampToValueAtTime(freq, now + glideTime);
        }
      }

      function stopCurrentVoice() {
        if (!currentVoice) return;
        const ctx = getAudio();
        if (!ctx) return;
        const now = ctx.currentTime;
        const { osc, gain } = currentVoice;

        gain.gain.cancelScheduledValues(now);
        gain.gain.setValueAtTime(gain.gain.value, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.06);

        osc.stop(now + 0.07);
        currentVoice = null;
      }

      // --- DRUMS: one-shots, 1-bar patterns ---
      const drumParts = ["kick","snare","ch","oh","perc"];
      const drumFiles = {
        kick: ["sounds2/Kick1.wav","sounds2/Kick2.wav","sounds2/Kick3.wav","sounds2/Kick4.wav"],
        snare:["sounds2/Snare1.wav","sounds2/Snare2.wav","sounds2/Snare3.wav","sounds2/Snare4.wav"],
        ch:   ["sounds2/CH1.wav","sounds2/CH2.wav","sounds2/CH3.wav","sounds2/CH4.wav"],
        oh:   ["sounds2/OH1.wav","sounds2/OH2.wav","sounds2/OH3.wav","sounds2/OH4.wav"],
        perc: ["sounds2/Perc1.wav","sounds2/Perc2.wav","sounds2/Perc3.wav","sounds2/Perc4.wav"]
      };

      let drumBuffers = {
        kick: [null,null,null,null],
        snare:[null,null,null,null],
        ch:   [null,null,null,null],
        oh:   [null,null,null,null],
        perc: [null,null,null,null]
      };

      let drumLoaded = false;
      let drumLoading = false;

      const drumPatterns = {
        kick: new Array(16).fill(false),
        snare:new Array(16).fill(false),
        ch:   new Array(16).fill(false),
        oh:   new Array(16).fill(false),
        perc: new Array(16).fill(false)
      };

      const drumMuted = {
        kick: false,
        snare:false,
        ch:   false,
        oh:   false,
        perc: false
      };

      const drumVariantIndex = {
        kick: 0,
        snare:0,
        ch:   0,
        oh:   0,
        perc: 0
      };

      async function loadDrumBuffers(ctx) {
        if (drumLoaded || drumLoading) return;
        drumLoading = true;
        try {
          for (const part of drumParts) {
            const urls = drumFiles[part];
            for (let i = 0; i < urls.length; i++) {
              const res = await fetch(urls[i]);
              const arr = await res.arrayBuffer();
              drumBuffers[part][i] = await ctx.decodeAudioData(arr);
            }
          }
          drumLoaded = true;
        } catch (e) {
          console.warn("Error loading drum one-shots:", e);
        } finally {
          drumLoading = false;
        }
      }

      function scheduleDrumsForStep(globalStep, when) {
        if (!drumLoaded) return;
        const ctx = getAudio();
        if (!ctx) return;

        // drums: 1-bar 16-step pattern, repeating across 4 bars
        const localStep = globalStep % 16;

        for (const part of drumParts) {
          if (drumMuted[part]) continue;
          if (!drumPatterns[part][localStep]) continue;

          const variant = drumVariantIndex[part] || 0;
          const buffer = drumBuffers[part][variant];
          if (!buffer) continue;

          const src = ctx.createBufferSource();
          const gain = ctx.createGain();

          src.buffer = buffer;
          gain.gain.setValueAtTime(0.4, when); // medium volume

          src.connect(gain);
          gain.connect(ctx.destination);
          src.start(when);
        }
      }

      // --- SYNTH SEQUENCER (64-step mono pattern) ---
      let synthPattern = new Array(TOTAL_STEPS).fill(null); // each step: {note, lengthSteps}
      let recState = "idle"; // "idle" | "count-in" | "recording" | "playing"
      let recStartTime = null;
      let recEndTime = null;
      let recStartGlobalStep = 0;
      let pendingNotes = {}; // mappedNote -> { startGlobalStep }
      let currentRecordedNote = null;

      function scheduleSynthForStep(globalStep, when) {
        if (recState !== "playing") return;
        const localStep = globalStep % TOTAL_STEPS;
        const evt = synthPattern[localStep];
        if (!evt) return;

        const duration = evt.lengthSteps * STEP_DUR;
        triggerSeqNote(evt.note, duration, when);
      }

      function triggerSeqNote(noteName, durationSeconds, startTime) {
        const mapped = scaleMap[noteName] || noteName;
        const freq = noteFreq[mapped];
        if (!freq) return;
        const ctx = getAudio();
        if (!ctx) return;

        const t0 = Math.max(startTime, ctx.currentTime);

        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        const distortion = ctx.createWaveShaper();

        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(freq, t0);

        distortion.curve = createDistortionCurve(4);
        distortion.oversample = "2x";

        const attack = 0.02;
        const decay = 0.06;
        const sustainLevel = 0.22;
        const total = Math.max(0.08, durationSeconds);
        const release = 0.08;
        const sustainTime = Math.max(0, total - (attack + decay + release));

        gain.gain.setValueAtTime(0, t0);
        gain.gain.linearRampToValueAtTime(0.23, t0 + attack);
        gain.gain.linearRampToValueAtTime(sustainLevel, t0 + attack + decay);
        gain.gain.setValueAtTime(sustainLevel, t0 + attack + decay + sustainTime);
        gain.gain.linearRampToValueAtTime(0, t0 + total);

        osc.connect(distortion);
        distortion.connect(gain);
        gain.connect(ctx.destination);

        osc.start(t0);
        osc.stop(t0 + total + 0.05);
      }

      function recordNoteOn(mappedNote) {
        if (recState !== "recording") return;
        const ctx = getAudio();
        if (!ctx || recStartTime === null || recEndTime === null) return;

        const now = ctx.currentTime;
        if (now < recStartTime || now > recEndTime) return;

        // monophonic: close any pending notes first
        Object.keys(pendingNotes).forEach(existing => {
          recordNoteOff(existing);
        });

        const globalStepNow = timeToGlobalStep(now);
        let localStart = globalStepNow - recStartGlobalStep;
        if (localStart < 0) localStart = 0;
        if (localStart >= TOTAL_STEPS) localStart = TOTAL_STEPS - 1;

        pendingNotes[mappedNote] = { startGlobalStep: globalStepNow, localStart };
      }

      function recordNoteOff(mappedNote) {
        if (recState !== "recording") return;
        const ctx = getAudio();
        if (!ctx || recStartTime === null || recEndTime === null) return;
        const data = pendingNotes[mappedNote];
        if (!data) return;

        const now = ctx.currentTime;
        const clamped = Math.max(recStartTime, Math.min(now, recEndTime));
        const globalStepOff = timeToGlobalStep(clamped);

        let localEnd = globalStepOff - recStartGlobalStep;
        if (localEnd <= data.localStart) localEnd = data.localStart + 1;
        if (localEnd > TOTAL_STEPS) localEnd = TOTAL_STEPS;

        const lengthSteps = localEnd - data.localStart;
        if (lengthSteps > 0) {
          synthPattern[data.localStart] = { note: mappedNote, lengthSteps };
        }

        delete pendingNotes[mappedNote];
      }

      function finalizeRecording() {
        // close any held notes at loop boundary
        Object.entries(pendingNotes).forEach(([note, data]) => {
          let localEnd = TOTAL_STEPS;
          if (localEnd <= data.localStart) localEnd = data.localStart + 1;
          const lengthSteps = localEnd - data.localStart;
          if (lengthSteps > 0) {
            synthPattern[data.localStart] = { note, lengthSteps };
          }
        });
        pendingNotes = {};
      }

      // --- DOM: step indicator ---
      const stepContainer = document.getElementById("step-indicator");
      const stepDots = [];
      if (stepContainer) {
        for (let i = 0; i < 16; i++) {
          const dot = document.createElement("div");
          dot.className = "step-dot";
          stepContainer.appendChild(dot);
          stepDots.push(dot);
        }
      }

      // --- DOM: drums grid & controls ---
      const drumGrids = {};
      const drumButtons = {};
      const drumSelects = {};

      function buildDrumGrid(part) {
        const gridEl = document.querySelector(`.drum-grid[data-part="${part}"]`);
        drumGrids[part] = gridEl;
        if (!gridEl) return;
        gridEl.innerHTML = "";
        // 4 rows (beats), 4 cols (1/e/&/a) = 16 steps
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            const idx = row * 4 + col; // step index 0..15
            const cell = document.createElement("div");
            cell.className = "drum-cell";
            cell.dataset.step = idx.toString();
            cell.addEventListener("click", () => {
              const current = drumPatterns[part][idx];
              drumPatterns[part][idx] = !current;
              cell.classList.toggle("active", !current);
            });
            gridEl.appendChild(cell);
          }
        }
      }

      drumParts.forEach((part) => {
        buildDrumGrid(part);
        const btn = document.querySelector(`.drum-button[data-part="${part}"]`);
        if (btn) {
          drumButtons[part] = btn;
          btn.addEventListener("click", () => {
            drumMuted[part] = !drumMuted[part];
            btn.classList.toggle("active", !drumMuted[part]);
          });
        }
        const sel = document.querySelector(`.drum-select[data-part="${part}"]`);
        if (sel) {
          drumSelects[part] = sel;
          sel.addEventListener("change", () => {
            const val = parseInt(sel.value || "1", 10);
            drumVariantIndex[part] = Math.max(0, Math.min(3, val - 1));
          });
        }
      });

      // --- DOM: transport + record ---
      const playBtn = document.getElementById("transport-play");
      const stopBtn = document.getElementById("transport-stop");
      const recBtn = document.getElementById("seq-record");

      if (playBtn) {
        playBtn.addEventListener("click", async () => {
          const ctx = getAudio();
          if (!ctx) return;
          await loadDrumBuffers(ctx);

          // reset pattern playback if already running
          stopTransport();
          synthPattern = new Array(TOTAL_STEPS).fill(null);
          recState = "idle";
          pendingNotes = {};
          currentRecordedNote = null;
          recStartTime = null;
          recEndTime = null;
          recBtn.classList.remove("recording","looping");
          recBtn.textContent = "rec";

          startTransport();
          playBtn.classList.add("active");
          if (stopBtn) stopBtn.classList.remove("active");
        });
      }

      if (stopBtn) {
        stopBtn.addEventListener("click", () => {
          stopTransport();
          recState = "idle";
          pendingNotes = {};
          currentRecordedNote = null;
          recStartTime = null;
          recEndTime = null;
          synthPattern = new Array(TOTAL_STEPS).fill(null);
          if (recBtn) {
            recBtn.classList.remove("recording","looping");
            recBtn.textContent = "rec";
          }
          if (playBtn) playBtn.classList.remove("active");
          stopBtn.classList.add("active");
        });
      }

      if (recBtn) {
        recBtn.addEventListener("click", async () => {
          const ctx = getAudio();
          if (!ctx) return;
          await loadDrumBuffers(ctx);

          // Cancel any current recording/playback and clear pattern
          if (recState !== "idle") {
            recState = "idle";
            finalizeRecording();
            synthPattern = new Array(TOTAL_STEPS).fill(null);
            pendingNotes = {};
            currentRecordedNote = null;
            recStartTime = null;
            recEndTime = null;
            recBtn.classList.remove("recording","looping");
            recBtn.textContent = "rec";
            return;
          }

          // If transport not running, start it after a 4-beat count-in.
          if (!transportRunning) {
            const now = ctx.currentTime;
            const countInStart = now;
            const countInEnd = countInStart + 4 * BEAT_DUR;

            // transport start and record start at the same time, after count-in
            transportStartTime = countInEnd;
            transportRunning = true;

            globalStepCounter = 0;
            nextStepTime = transportStartTime + STEP_DUR;
            lastQuarterVisual = null;

            if (!stepTimer) {
              stepTimer = setInterval(() => {
                const c = getAudio();
                if (!c || !transportRunning) return;
                const now2 = c.currentTime;
                const lookahead = 0.1;

                while (nextStepTime <= now2 + lookahead) {
                  globalStepCounter++;
                  const localStep = globalStepCounter % TOTAL_STEPS;

                  if (stepDots.length) {
                    const quarterIndex = Math.floor(localStep / 4);
                    if (quarterIndex !== lastQuarterVisual) {
                      stepDots.forEach((dot, idx) => {
                        dot.classList.toggle("active", idx === quarterIndex);
                      });
                      lastQuarterVisual = quarterIndex;
                    }
                  }

                  scheduleDrumsForStep(localStep, nextStepTime);
                  scheduleSynthForStep(localStep, nextStepTime);

                  nextStepTime += STEP_DUR;
                }
              }, 25);
            }

            // count-in display 4,3,2,1
            recState = "count-in";
            recBtn.classList.add("recording");
            recBtn.classList.remove("looping");
            recBtn.textContent = "4";

            for (let i = 0; i < 4; i++) {
              const displayNum = 4 - i;
              const t = countInStart + i * BEAT_DUR;
              const delay = Math.max(0, (t - now) * 1000);
              setTimeout(() => {
                if (recState === "count-in") {
                  recBtn.textContent = displayNum.toString();
                }
              }, delay);
            }

            // start recording exactly at 1.1
            recStartTime = transportStartTime;
            recEndTime = recStartTime + LOOP_BEATS * BEAT_DUR;
            recStartGlobalStep = timeToGlobalStep(recStartTime);

            const toRecordMs = Math.max(0, (recStartTime - now) * 1000);
            setTimeout(() => {
              if (recState !== "count-in") return;
              recState = "recording";
              synthPattern = new Array(TOTAL_STEPS).fill(null);
              pendingNotes = {};
              recBtn.textContent = "rec*";
            }, toRecordMs);

            const toEndMs = Math.max(0, (recEndTime - now) * 1000);
            setTimeout(() => {
              if (recState !== "recording") return;
              recState = "playing";
              finalizeRecording();
              recBtn.classList.remove("recording");
              recBtn.classList.add("looping");
              recBtn.textContent = "looping";
            }, toEndMs);

            if (playBtn) playBtn.classList.add("active");
            if (stopBtn) stopBtn.classList.remove("active");

          } else {
            // Transport is running: arm recording for NEXT full loop at 1.1
            const now = ctx.currentTime;
            const elapsedBeatsFloat = (now - transportStartTime) / BEAT_DUR;
            const currentLoopIndex = Math.floor(elapsedBeatsFloat / LOOP_BEATS);
            const recordStartLoopIndex = currentLoopIndex + 1;
            const recordStartBeatGlobal = recordStartLoopIndex * LOOP_BEATS; // beat index from transportStart

            const recStart = transportStartTime + recordStartBeatGlobal * BEAT_DUR;
            const recEnd = recStart + LOOP_BEATS * BEAT_DUR;

            // count-in over last 4 beats of current loop (4,3,2,1)
            recState = "count-in";
            recBtn.classList.add("recording");
            recBtn.classList.remove("looping");
            recBtn.textContent = "4";

            for (let i = 0; i < 4; i++) {
              const beatIndex = recordStartBeatGlobal - (4 - i); // beats before recStart
              const t = transportStartTime + beatIndex * BEAT_DUR;
              const displayNum = 4 - i;
              const delay = Math.max(0, (t - now) * 1000);
              setTimeout(() => {
                if (recState === "count-in") {
                  recBtn.textContent = displayNum.toString();
                }
              }, delay);
            }

            recStartTime = recStart;
            recEndTime = recEnd;
            recStartGlobalStep = Math.round((recordStartBeatGlobal * BEATS_PER_BAR * 0 + recordStartBeatGlobal * 4)); // 4 steps per beat
            recStartGlobalStep = recordStartBeatGlobal * 4;

            const toRecordMs = Math.max(0, (recStartTime - now) * 1000);
            setTimeout(() => {
              if (recState !== "count-in") return;
              recState = "recording";
              synthPattern = new Array(TOTAL_STEPS).fill(null);
              pendingNotes = {};
              recBtn.textContent = "rec*";
            }, toRecordMs);

            const toEndMs = Math.max(0, (recEndTime - now) * 1000);
            setTimeout(() => {
              if (recState !== "recording") return;
              recState = "playing";
              finalizeRecording();
              recBtn.classList.remove("recording");
              recBtn.classList.add("looping");
              recBtn.textContent = "looping";
            }, toEndMs);
          }
        });
      }

      // --- PIANO / POINTER INPUT & RECORD HOOKS ---
      const piano = document.querySelector(".piano");
      const keys = document.querySelectorAll(".key[data-note]");
      if (!piano || !keys.length) return;

      let pointerDown = false;
      let activeTouchId = null;
      let activeKeyEl = null;

      function setActiveKey(newKey) {
        if (activeKeyEl === newKey) return;
        if (activeKeyEl) {
          activeKeyEl.classList.remove("is-down");
        }
        activeKeyEl = newKey;
        if (activeKeyEl) {
          activeKeyEl.classList.add("is-down");
        }
      }

      function getKeyFromTarget(target) {
        if (!target) return null;
        if (target.classList && target.classList.contains("key") && target.dataset.note) {
          return target;
        }
        return target.closest ? target.closest(".key[data-note]") : null;
      }

      // Mouse
      keys.forEach((key) => {
        key.addEventListener("mousedown", (e) => {
          e.preventDefault();
          pointerDown = true;
          const rawNote = key.getAttribute("data-note");
          if (!rawNote) return;
          const mapped = scaleMap[rawNote] || rawNote;
          currentRecordedNote = mapped;

          setActiveKey(key);
          if (recState === "recording") {
            recordNoteOn(mapped);
          }
          startOrGlideToNote(rawNote);
        });
      });

      window.addEventListener("mouseup", () => {
        if (!pointerDown) return;
        pointerDown = false;
        if (recState === "recording" && currentRecordedNote) {
          recordNoteOff(currentRecordedNote);
        }
        currentRecordedNote = null;
        setActiveKey(null);
        stopCurrentVoice();
      });

      piano.addEventListener("mousemove", (e) => {
        if (!pointerDown) return;
        const el = document.elementFromPoint(e.clientX, e.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const rawNote = key.getAttribute("data-note");
        if (!rawNote) return;
        const mapped = scaleMap[rawNote] || rawNote;

        if (mapped !== currentRecordedNote) {
          if (recState === "recording" && currentRecordedNote) {
            recordNoteOff(currentRecordedNote);
          }
          if (recState === "recording") {
            recordNoteOn(mapped);
          }
          currentRecordedNote = mapped;
        }

        setActiveKey(key);
        startOrGlideToNote(rawNote);
      });

      // Touch
      piano.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (activeTouchId !== null) return;
        const touch = e.changedTouches[0];
        activeTouchId = touch.identifier;
        pointerDown = true;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const rawNote = key.getAttribute("data-note");
        if (!rawNote) return;
        const mapped = scaleMap[rawNote] || rawNote;

        currentRecordedNote = mapped;
        setActiveKey(key);
        if (recState === "recording") {
          recordNoteOn(mapped);
        }
        startOrGlideToNote(rawNote);
      }, { passive: false });

      piano.addEventListener("touchmove", (e) => {
        if (activeTouchId === null) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        const el = document.elementFromPoint(touch.clientX, touch.clientY);
        const key = getKeyFromTarget(el);
        if (!key) return;
        const rawNote = key.getAttribute("data-note");
        if (!rawNote) return;
        const mapped = scaleMap[rawNote] || rawNote;

        if (mapped !== currentRecordedNote) {
          if (recState === "recording" && currentRecordedNote) {
            recordNoteOff(currentRecordedNote);
          }
          if (recState === "recording") {
            recordNoteOn(mapped);
          }
          currentRecordedNote = mapped;
        }

        setActiveKey(key);
        startOrGlideToNote(rawNote);
      }, { passive: false });

      function endTouch(e) {
        if (activeTouchId === null) return;
        const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
        if (!touch) return;
        activeTouchId = null;
        pointerDown = false;
        if (recState === "recording" && currentRecordedNote) {
          recordNoteOff(currentRecordedNote);
        }
        currentRecordedNote = null;
        setActiveKey(null);
        stopCurrentVoice();
      }

      piano.addEventListener("touchend", endTouch, { passive: false });
      piano.addEventListener("touchcancel", endTouch, { passive: false });
    });

    // Drunk-vision cursor trail
    document.addEventListener("mousemove", (e) => {
      const trail = document.createElement("div");
      trail.className = "cursor-trail";

      trail.style.left = e.clientX + "px";
      trail.style.top = e.clientY + "px";

      const scale = 0.9 + Math.random() * 0.4;
      trail.style.width = 14 * scale + "px";
      trail.style.height = 14 * scale + "px";
      trail.style.background = `rgba(0, 0, 0, ${0.08 + Math.random() * 0.07})`;
      trail.style.filter = "blur(" + (4 + Math.random() * 3) + "px)";

      document.body.appendChild(trail);
      setTimeout(() => trail.remove(), 750);
    });
  </script>

</body>
</html>